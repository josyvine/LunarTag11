package com.lunartag.app.ui.admin;

import android.app.AlertDialog;
import android.app.TimePickerDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.text.InputType;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.TimePicker;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;
import androidx.recyclerview.widget.LinearLayoutManager;

import com.lunartag.app.databinding.FragmentScheduleEditorBinding;

import org.json.JSONArray;
import org.json.JSONException;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Locale;

public class ScheduleEditorFragment extends Fragment {

    // Schedule Storage Preferences
    private static final String PREFS_SCHEDULE = "LunarTagSchedule";
    private static final String KEY_TIMESTAMP_LIST = "timestamp_list";

    // Feature Toggle Preferences (Admin Mode)
    private static final String PREFS_TOGGLES = "LunarTagFeatureToggles";
    private static final String KEY_ADMIN_ENABLED = "customTimestampEnabled";

    // General Settings Preferences (To read Shift Times)
    private static final String PREFS_SETTINGS = "LunarTagSettings";
    private static final String KEY_SHIFT_START = "shift_start";
    private static final String KEY_SHIFT_END = "shift_end";

    private FragmentScheduleEditorBinding binding;
    private ScheduleAdapter adapter;
    private List<Long> timestampList;

    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        binding = FragmentScheduleEditorBinding.inflate(inflater, container, false);
        return binding.getRoot();
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        // Check Remote Config to see if Admin UI should be shown
        SharedPreferences featurePrefs = requireContext().getSharedPreferences(PREFS_TOGGLES, Context.MODE_PRIVATE);
        boolean isFeatureEnabled = featurePrefs.getBoolean(KEY_ADMIN_ENABLED, false);

        if (!isFeatureEnabled) {
            binding.getRoot().setVisibility(View.GONE);
            return;
        }
        
        binding.getRoot().setVisibility(View.VISIBLE);

        timestampList = loadTimestamps();

        adapter = new ScheduleAdapter(timestampList, new ScheduleAdapter.OnTimestampDeleteListener() {
            @Override
            public void onTimestampDeleted(int position) {
                timestampList.remove(position);
                adapter.notifyItemRemoved(position);
                saveTimestamps(timestampList);
                updateCountUI();
            }
        });

        binding.recyclerViewTimestamps.setLayoutManager(new LinearLayoutManager(getContext()));
        binding.recyclerViewTimestamps.setAdapter(adapter);

        updateCountUI();
        setupClickListeners();
    }

    private void setupClickListeners() {
        binding.buttonAddTimestamp.setOnClickListener(v -> showTimePickerAndAdd());
        binding.buttonAutoGenerate.setOnClickListener(v -> showAutoGenerateDialog());
    }

    private void updateCountUI() {
        if (binding == null) return;
        
        int count = timestampList.size();
        binding.textSlotsRemaining.setText("Slots available: " + count);

        if (count == 0) {
            binding.textNoTimestamps.setVisibility(View.VISIBLE);
            binding.recyclerViewTimestamps.setVisibility(View.GONE);
        } else {
            binding.textNoTimestamps.setVisibility(View.GONE);
            binding.recyclerViewTimestamps.setVisibility(View.VISIBLE);
        }
    }

    // --- Logic: Add Single Timestamp ---

    private void showTimePickerAndAdd() {
        Calendar cal = Calendar.getInstance();
        int hour = cal.get(Calendar.HOUR_OF_DAY);
        int minute = cal.get(Calendar.MINUTE);

        TimePickerDialog picker = new TimePickerDialog(getContext(), new TimePickerDialog.OnTimeSetListener() {
            @Override
            public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
                
                // 1. Create a Calendar object for the user's selection
                Calendar selectedTime = Calendar.getInstance();
                selectedTime.set(Calendar.HOUR_OF_DAY, hourOfDay);
                selectedTime.set(Calendar.MINUTE, minute);
                selectedTime.set(Calendar.SECOND, 0);
                selectedTime.set(Calendar.MILLISECOND, 0);
                
                // 2. Smart Logic to detect "Tomorrow"
                if (!timestampList.isEmpty()) {
                    // If we have existing items, and this new time is earlier than the last one,
                    // assume the user means the next day (e.g., adding 1 AM after 11 PM).
                    long lastTimestamp = timestampList.get(timestampList.size() - 1);
                    while (selectedTime.getTimeInMillis() <= lastTimestamp) {
                        selectedTime.add(Calendar.DAY_OF_MONTH, 1);
                    }
                } else {
                    // If list is empty, but selected time is earlier than "now", assume tomorrow.
                    Calendar now = Calendar.getInstance();
                    if (selectedTime.before(now)) {
                        selectedTime.add(Calendar.DAY_OF_MONTH, 1);
                    }
                }
                
                addTimestamp(selectedTime.getTimeInMillis());
            }
        }, hour, minute, false);
        picker.show();
    }

    private void addTimestamp(long timestamp) {
        timestampList.add(timestamp);
        Collections.sort(timestampList); 
        adapter.notifyDataSetChanged();
        saveTimestamps(timestampList);
        updateCountUI();
    }

    // --- Logic: Auto-Generate Schedule (UPDATED TO USE SETTINGS) ---

    private void showAutoGenerateDialog() {
        // 1. Retrieve the Shift Start/End times from General Settings
        SharedPreferences settingsPrefs = requireContext().getSharedPreferences(PREFS_SETTINGS, Context.MODE_PRIVATE);
        // Default to 8:00 AM if nothing is saved in settings
        String startStr = settingsPrefs.getString(KEY_SHIFT_START, "08:00 AM");
        String endStr = settingsPrefs.getString(KEY_SHIFT_END, "08:00 AM");

        AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
        builder.setTitle("Auto-Generate Schedule");
        
        // Update message to show the actual configured Shift Times
        builder.setMessage("Generating schedule from Shift Start (" + startStr + ") to Shift End (" + endStr + ").\n\nEnter Interval (Minutes):");

        final EditText inputInterval = new EditText(getContext());
        inputInterval.setInputType(InputType.TYPE_CLASS_NUMBER);
        inputInterval.setHint("Interval (Default: 30)");
        
        LinearLayout container = new LinearLayout(getContext());
        container.setOrientation(LinearLayout.VERTICAL);
        container.setPadding(50, 20, 50, 20);
        container.addView(inputInterval);
        
        builder.setView(container);

        builder.setPositiveButton("Generate", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                String intervalStr = inputInterval.getText().toString();
                int interval = 30; // Default 30 mins
                if (!intervalStr.isEmpty()) {
                    try {
                        interval = Integer.parseInt(intervalStr);
                    } catch (NumberFormatException e) { }
                }
                
                // 2. Parse the strings and generate based on settings
                parseAndGenerate(startStr, endStr, interval);
            }
        });

        builder.setNegativeButton("Cancel", null);
        builder.setNeutralButton("Clear All", (dialog, which) -> {
            timestampList.clear();
            adapter.notifyDataSetChanged();
            saveTimestamps(timestampList);
            updateCountUI();
        });

        builder.show();
    }

    /**
     * Parses the "hh:mm a" strings from settings and calls generateSchedule.
     */
    private void parseAndGenerate(String startStr, String endStr, int interval) {
        SimpleDateFormat sdf = new SimpleDateFormat("hh:mm a", Locale.US);
        
        try {
            // Parse Start Time
            Date startDate = sdf.parse(startStr);
            Calendar startCal = Calendar.getInstance();
            if (startDate != null) startCal.setTime(startDate);
            int startHour = startCal.get(Calendar.HOUR_OF_DAY);
            int startMin = startCal.get(Calendar.MINUTE);

            // Parse End Time
            Date endDate = sdf.parse(endStr);
            Calendar endCal = Calendar.getInstance();
            if (endDate != null) endCal.setTime(endDate);
            int endHour = endCal.get(Calendar.HOUR_OF_DAY);
            int endMin = endCal.get(Calendar.MINUTE);

            // Call the generation logic with the parsed hours/minutes
            generateSchedule(startHour, startMin, endHour, endMin, interval);

        } catch (ParseException e) {
            Toast.makeText(getContext(), "Error parsing Shift Times. Please check Settings.", Toast.LENGTH_LONG).show();
            e.printStackTrace();
        }
    }

    private void generateSchedule(int startHour, int startMin, int endHour, int endMin, int intervalMinutes) {
        timestampList.clear();
        
        // Set up the Start Calendar (Today)
        Calendar current = Calendar.getInstance();
        current.set(Calendar.HOUR_OF_DAY, startHour);
        current.set(Calendar.MINUTE, startMin);
        current.set(Calendar.SECOND, 0);
        current.set(Calendar.MILLISECOND, 0);

        // Set up the End Calendar
        Calendar end = Calendar.getInstance();
        // Sync date with current first to ensure accurate comparison
        end.setTimeInMillis(current.getTimeInMillis());
        end.set(Calendar.HOUR_OF_DAY, endHour);
        end.set(Calendar.MINUTE, endMin);
        end.set(Calendar.SECOND, 0);
        end.set(Calendar.MILLISECOND, 0);

        // LOGIC FOR OVERNIGHT SHIFTS:
        // If End Time is before Start Time (e.g. Start 8 PM, End 4 AM), add 1 day to End.
        // If End Time equals Start Time (e.g. 8 AM to 8 AM), add 1 day to End (24 hour shift).
        if (end.before(current) || end.equals(current)) {
            end.add(Calendar.DAY_OF_MONTH, 1);
        }

        // Loop and add timestamps based on the interval
        while (current.before(end) || current.equals(end)) {
            timestampList.add(current.getTimeInMillis());
            current.add(Calendar.MINUTE, intervalMinutes);
        }

        Collections.sort(timestampList);
        adapter.notifyDataSetChanged();
        saveTimestamps(timestampList);
        updateCountUI();
        Toast.makeText(getContext(), "Generated " + timestampList.size() + " slots based on Shift Settings.", Toast.LENGTH_SHORT).show();
    }

    private void saveTimestamps(List<Long> list) {
        SharedPreferences prefs = requireContext().getSharedPreferences(PREFS_SCHEDULE, Context.MODE_PRIVATE);
        JSONArray jsonArray = new JSONArray();
        for (Long ts : list) {
            jsonArray.put(ts);
        }
        prefs.edit().putString(KEY_TIMESTAMP_LIST, jsonArray.toString()).apply();
    }

    private List<Long> loadTimestamps() {
        List<Long> list = new ArrayList<>();
        SharedPreferences prefs = requireContext().getSharedPreferences(PREFS_SCHEDULE, Context.MODE_PRIVATE);
        String json = prefs.getString(KEY_TIMESTAMP_LIST, "[]");
        try {
            JSONArray jsonArray = new JSONArray(json);
            for (int i = 0; i < jsonArray.length(); i++) {
                list.add(jsonArray.getLong(i));
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
        Collections.sort(list);
        return list;
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();
        binding = null;
    }
}